// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// Action action
//
// swagger:discriminator Action type
type Action interface {
	runtime.Validatable

	// Display name of the action.
	DisplayName() string
	SetDisplayName(string)

	// Unique ID of the action.
	// Read Only: true
	ID() string
	SetID(string)

	// Unique IDs of the rules that are tied to the action.
	// Required: true
	// Max Items: 1
	// Min Items: 1
	Rules() []string
	SetRules([]string)

	// Type of the action.
	// Required: true
	Type() string
	SetType(string)

	// AdditionalProperties in base type shoud be handled just like regular properties
	// At this moment, the base type property is pushed down to the subtype
}

type action struct {
	displayNameField string

	idField string

	rulesField []string

	typeField string
}

// DisplayName gets the display name of this polymorphic type
func (m *action) DisplayName() string {
	return m.displayNameField
}

// SetDisplayName sets the display name of this polymorphic type
func (m *action) SetDisplayName(val string) {
	m.displayNameField = val
}

// ID gets the id of this polymorphic type
func (m *action) ID() string {
	return m.idField
}

// SetID sets the id of this polymorphic type
func (m *action) SetID(val string) {
	m.idField = val
}

// Rules gets the rules of this polymorphic type
func (m *action) Rules() []string {
	return m.rulesField
}

// SetRules sets the rules of this polymorphic type
func (m *action) SetRules(val []string) {
	m.rulesField = val
}

// Type gets the type of this polymorphic type
func (m *action) Type() string {
	return "Action"
}

// SetType sets the type of this polymorphic type
func (m *action) SetType(val string) {
}

// UnmarshalActionSlice unmarshals polymorphic slices of Action
func UnmarshalActionSlice(reader io.Reader, consumer runtime.Consumer) ([]Action, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []Action
	for _, element := range elements {
		obj, err := unmarshalAction(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalAction unmarshals polymorphic Action
func UnmarshalAction(reader io.Reader, consumer runtime.Consumer) (Action, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalAction(data, consumer)
}

func unmarshalAction(data []byte, consumer runtime.Consumer) (Action, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the type property.
	var getType struct {
		Type string `json:"type"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("type", "body", getType.Type); err != nil {
		return nil, err
	}

	// The value of type is used to determine which type to create and unmarshal the data into
	switch getType.Type {
	case "Action":
		var result action
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "ActionGroupsAction":
		var result ActionGroupsAction
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "EmailAction":
		var result EmailAction
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "LogicAppsAction":
		var result LogicAppsAction
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "PowerAutomateAction":
		var result PowerAutomateAction
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "WebhookAction":
		var result WebhookAction
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	}
	return nil, errors.New(422, "invalid type value: %q", getType.Type)
}

// Validate validates this action
func (m *action) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRules(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *action) validateRules(formats strfmt.Registry) error {

	if err := validate.Required("rules", "body", m.Rules()); err != nil {
		return err
	}

	iRulesSize := int64(len(m.Rules()))

	if err := validate.MinItems("rules", "body", iRulesSize, 1); err != nil {
		return err
	}

	if err := validate.MaxItems("rules", "body", iRulesSize, 1); err != nil {
		return err
	}

	return nil
}
